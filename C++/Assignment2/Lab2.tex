%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT 435
% Fall 2023
% Lab/Assignment/Project 2
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt,DIV=13]{scrartcl} 

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm,xfrac} % Math packages
\usepackage{sectsty} % Allows customizing section commands
\usepackage{graphicx}
\usepackage[lined,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{parskip}
\usepackage{lastpage}
\usepackage{listings}
\usepackage[colorlinks=true, urlcolor=blue]{hyperref}
\lstset{
    language=C++
}

\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{page \thepage\ of \pageref{LastPage}} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs.

\binoppenalty=3000
\relpenalty=3000

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2023 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Assignment Two  \\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Collin Drake \\ \normalsize Collin.Drake1@Marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}
\maketitle % Print the title

%----------------------------------------------------------------------------------------
%   start PROBLEM ONE
%----------------------------------------------------------------------------------------
\section{Linear Search}

\subsection{The Algorithm}
The linear, or sequential, search algorithm is an algorithm used to search a collection of elements until it reaches the end of the collection or until the desired object is found. This algorithm works by simply iterating one by one through each element and comparing it to the desired target. If the element is found then the search stops, otherwise, the search continues until it reaches the end of the array. The time complexity of linear search is linear time, O(n), meaning that as the input size grows, the time it takes to search through the collection of items grows linearly.

\subsubsection*{Linear Search}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //linear search
    float Searching:: linearSearch(vector<string>& magicItems, vector<string>& randomItems){
        //total comparisons
        int totlinComparisons = 0;
    
        //iterate through both vectors
        for(int i = 0; i < randomItems.size(); i++){
            //comparisons for each magic item
            int lComparisons = 0;
            string current = randomItems[i];
            for(int j = 0 ; j < magicItems.size(); j++){
                //compare each element in magic items to current element in random items
                lComparisons++;
                if(current.compare(magicItems[j]) == 0){
                    //if found break loop
                    break;
                }
            }
            //add to total
            totlinComparisons += lComparisons;
        }
        //find everage and round
        return (static_cast<float>(totlinComparisons) / static_cast<float>(randomItems.size()));
    }

\end{lstlisting}

\pagebreak

\subsection{Asymptotic Analysis}
In our scenario, given two different-sized collections, one larger and one smaller, when using linear search to look through the larger collection for each element in the smaller collection, the running time results in O(n). Despite the fact that there is a nested loop involving two different-sized arrays, resulting in an O(m * n) time complexity, this still results in O(n), constant time, as we prioritize the dominant factor and throw away constants.


%----------------------------------------------------------------------------------------
%   end PROBLEM ONE
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%   start PROBLEM TWO
%----------------------------------------------------------------------------------------


\section{Binary Search}

\subsection{The Algorithm}
The algorithm binary search is a searching algorithm used to search a sorted collection of items by dividing the searchable collection with each comparison. Binary search works by checking if the target element is equal to the middle object, greater than the middle object, or less than the middle object. With each comparison, the searchable collection is reduced until the target is found or the entire array is searched. Generally, the binary search time complexity is O(log n), logarithmic time. 

\pagebreak

\subsubsection*{Binary Search}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //binary search
    float Searching:: binarySearch(vector<string>& magicItems, vector<string>& randomItems){
        //keep track of total comparisons
        int totbinComparisons = 0;
        
        //iterate through each element in random items
        for(int i = 0; i < randomItems.size(); i++){
            //comparisons for each magic item
            //current is the target
            //create start and end index variables
            int bComparisons = 0;
            string target = randomItems[i];
            int start = 0;
            int end = magicItems.size() - 1;
    
            while(start <= end){
                bComparisons++;
                //find middle index
                int middle = (start + end) / 2;
    
                //check if target is middle
                if(magicItems[middle] == target){
                    break;
                }
                //if target is greater than middle, ignore left half
                if(magicItems[middle].compare(target) < 0){
                    start = middle + 1;
    
                }
                //if target is less than middle, ignore right half
                else{
                    end = middle - 1;
                }
            }
            //add to total
            totbinComparisons += bComparisons;
        }
        //find average and round
        return (static_cast<float>(totbinComparisons) / 
        static_cast<float>(randomItems.size()));
    }

\end{lstlisting}

\subsection{Asymptotic Analysis}
In our case given two collections of items, one being a larger sorted array and the other being a smaller unsorted array, when using binary search to look through the bigger collection for each target element in the smaller collection the time complexity is O(log n). Initially, this might seem incorrect, as we are given two collections, the random items and magic items arrays. However, we prioritize the dominant factor, the magic items array, and throw away constants. As a result, our binary search algorithm remains in O(log n), logarithmic time. 


%----------------------------------------------------------------------------------------
%   end PROBLEM Two
%----------------------------------------------------------------------------------------
\pagebreak
%----------------------------------------------------------------------------------------
%   start PROBLEM Three
%----------------------------------------------------------------------------------------
\section{Hash table}

\subsection{The Data Structure}
A hash table is a data structure that can be imagined as a vertical array that stores elements in key-value pairs. To store these pairs hash tables use hash functions, which determine the position a value is stored based on the hash of the given input. When a hash function produces the same hash for multiple different values this is what we call a hash collision. Hash collisions are resolved by hash tables that use chaining. Chaining in a hash table is when each index within the array contains its own linked list, allowing multiple duplicate hashes to be stored within the same index. There are two fundamental operations that make up a hash table: put and get.

\subsubsection*{constructor}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //hash table constructor
    HashTable:: HashTable(){
        this->hashTableSize = 250;
    
        //set each node to null and allocate memory for hash table
        hashTable.resize(hashTableSize, nullptr);
    }
    
\end{lstlisting}

\subsubsection{Put}
The put function of a hash table adds the input value to an index within the table. When the put function is called, the given value is hashed and mapped to a specific index within the array. If there are multiple other nodes within the mapped index, the new node is placed at the head of that index's linked list, and its next pointer is directed toward the previous head. Otherwise, if there are no collisions at that index, the new node simply becomes the head of that index.


\subsubsection*{Put}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //adds a value to the hash table
    void HashTable:: put(string input){
        //hash and find the index of input
        int hash = hashFunction(input);
    
        //create a new node with the given input
        Node* newNode = new Node(input);
    
        //check if hashed index contains other values (collision)
        if(hashTable[hash] == nullptr){ 
            //if there is no collision set new node to head
            hashTable[hash] = newNode;
        }
        else{ 
            //set next pointer to current head and set the head as the new node
            newNode->next = hashTable[hash];
            hashTable[hash] = newNode;
        }
    }
    
\end{lstlisting}

\pagebreak

\subsubsection{Get}
The get function of a hash table simply returns the value hashed by a given key. When the get function is called, the key is hashed to find the target index, walking through its linked list, and returning either the value that matches the given key, or null if the value does not exist. Furthermore, the get function simply returns a value that is matched to its input key and does not remove anything from the hash table.


\subsubsection*{Get}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //finds the given value in the hash table and returns the comparison count
    int HashTable:: get(string key){
        //count comparisons for each get call
        int comparisons = 1;
        //hash and find the index of the target
        int hash = hashFunction(key);
    
        //temp node to iterate through linked list
        Node* current = hashTable[hash];
    
        //check if index is populated
        if(hashTable[hash] == nullptr){
            //throw exception if index is empty
            throw invalid_argument("This value is not in the hash table");
        }
        //if index is populated iterate through nodes
        else{
            //walk down list untl you find the value
            while(current != nullptr){
                comparisons++;
                if(current->val == key){
                    break;
                }
                else{
                    //if the current node is not the target move to the next
                    current = current->next;
                }
            }
        }
        return comparisons;
    }
    
\end{lstlisting}

\subsubsection{hashing}
The hash function of a hash table calculates the hash value of a given key to find its index. It does this by summing all of the ASCII values of each letter within the given input and finding its remainder when dividing it by the size of the hash table. This number is the index in which the value will be stored.

\pagebreak

\subsubsection*{Hash Function}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //hashing function to find the hash code for the given input
    int HashTable:: hashFunction(string input){
        //sum of ascii values
        int letterTotal = 0; 
    
        //finds the ascii value of each letter in the input
        for(int i = 0; i < input.length(); i++){
            char currentLetter = input[i];
            int asciiVal = int(currentLetter);
            letterTotal += asciiVal;
        }
        //find the hash code for the input and return it
        return (letterTotal % hashTableSize);
    }
    
\end{lstlisting}


\subsection{Asymptotic Analysis}
When given a hash table with chaining, there are two fundamental operations that can be performed: put and get. Both functions can be characterized by their time complexities O(1) and O(1 + $\alpha$). When it comes to adding or "putting" an element in the hash table, the worst-case time complexity would be constant time, or O(1), as the new node will become the head of the hashed index regardless of collision. Getting an element from a hash table would have a time complexity of constant time plus alpha, O(1 + $\alpha$). This is because when receiving or "getting" an element from a hash table, if the element is the head of the index it is a constant time operation, however, if the element is further down that index's linked list, the time complexity grows at a larger rate. Furthermore, in a hash table, values are not distributed equally meaning, each index's retrieval will differentiate based on its size or number of elements needed to be iterated through. Therefore, the average index's elements that need to be iterated through are represented as the load factor or $\alpha$.
%----------------------------------------------------------------------------------------
%   end PROBLEM THREE
%----------------------------------------------------------------------------------------

\pagebreak

%----------------------------------------------------------------------------------------
%   Appendix
%----------------------------------------------------------------------------------------

\section{Appendix}

\subsection{Comparisons and Time Complexity}
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            Linear Search & 333.50 & $O(n)$  \\ \hline
            Binary Search & 7.95 & $O(logn)$ \\ \hline
            Hashing With Chaining     & 3.38 & O(1 + $\alpha$) \\ \hline
        \end{tabular}
    \end{center}

\subsubsection*{Searching cpp}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //This file creates the search classes for linear and binary search
    #include "Searching.hpp"
    
    #include <vector>
    #include <string>
    
    //linear search
    float Searching:: linearSearch(vector<string>& magicItems, vector<string>& randomItems){
        //total comparisons
        int totlinComparisons = 0;
    
        //iterate through both vectors
        for(int i = 0; i < randomItems.size(); i++){
            //comparisons for each magic item
            int lComparisons = 0;
            string current = randomItems[i];
            for(int j = 0 ; j < magicItems.size(); j++){
                //compare each element in magic items to current element in random items
                lComparisons++;
                if(current.compare(magicItems[j]) == 0){
                    //if found break loop
                    break;
                }
            }
            //add to total
            totlinComparisons += lComparisons;
        }
        //find everage and round
        return (static_cast<float>(totlinComparisons) / 
        static_cast<float>(randomItems.size()));
    }
    
    //binary search
    float Searching:: binarySearch(vector<string>& magicItems, vector<string>& randomItems){
        //keep track of total comparisons
        int totbinComparisons = 0;
        
        //iterate through each element in random items
        for(int i = 0; i < randomItems.size(); i++){
            //comparisons for each magic item
            //current is the target
            //create start and end index variables
            int bComparisons = 0;
            string target = randomItems[i];
            int start = 0;
            int end = magicItems.size() - 1;
    
            while(start <= end){
                bComparisons++;
                //find middle index
                int middle = (start + end) / 2;
    
                //check if target is middle
                if(magicItems[middle] == target){
                    break;
                }
                //if target is greater than middle, ignore left half
                if(magicItems[middle].compare(target) < 0){
                    start = middle + 1;
    
                }
                //if target is less than middle, ignore right half
                else{
                    end = middle - 1;
                }
            }
            //add to total
            totbinComparisons += bComparisons;
        }
        //find average and round
        return (static_cast<float>(totbinComparisons) / 
        static_cast<float>(randomItems.size()));
    }
    
\end{lstlisting}

\subsubsection*{Hashing cpp}
    \lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
    \begin{lstlisting}[frame=single, ]
    //this file creates the hashing and chaining functions for a hash table
    #include "Hashing.hpp"
    
    #include <vector>
    #include <string>
    #include <stdexcept>
    
    //hash table constructor
    HashTable:: HashTable(){
        this->hashTableSize = 250;
    
        //set each node to null and allocate memory for hash table
        hashTable.resize(hashTableSize, nullptr);
    }
    
    //adds a value to the hash table
    void HashTable:: put(string input){
        //hash and find the index of input
        int hash = hashFunction(input);
    
        //create a new node with the given input
        Node* newNode = new Node(input);
    
        //check if hashed index contains other values (collision)
        if(hashTable[hash] == nullptr){ 
            //if there is no collision set new node to head
            hashTable[hash] = newNode;
        }
        else{ 
            //set next pointer to current head and set the head as the new node
            newNode->next = hashTable[hash];
            hashTable[hash] = newNode;
        }
    }
    
    //finds the given value in the hash table and returns the comparison count
    int HashTable:: get(string key){
        //count comparisons for each get call
        int comparisons = 1;
    
        //hash and find the index of the target
        int hash = hashFunction(key);
    
        //temp node to iterate through linked list
        Node* current = hashTable[hash];
    
        //check if index is populated
        if(hashTable[hash] == nullptr){
            //throw exception if index is empty
            throw invalid_argument("This value is not in the hash table");
        }
        //if index is populated iterate through nodes
        else{
            //walk down list untl you find the value
            while(current != nullptr){
                comparisons++;
                if(current->val == key){
                    break;
                }
                else{
                    //if the current node is not the target move to the next
                    current = current->next;
                }
            }
        }
        return comparisons;
    }
    
    //hashing function to find the hash code for the given input
    int HashTable:: hashFunction(string input){
        //sum of ascii values
        int letterTotal = 0; 
    
        //finds the ascii value of each letter in the input
        for(int i = 0; i < input.length(); i++){
            char currentLetter = input[i];
            int asciiVal = int(currentLetter);
            letterTotal += asciiVal;
        }
        //find the hash code for the input and return it
        return (letterTotal % hashTableSize);
    }

\end{lstlisting}

%----------------------------------------------------------------------------------------
%   Links of References
%----------------------------------------------------------------------------------------
\pagebreak

\section{References}

\subsection{Links}
Below are the resources I have used to create simple, readable, and beautiful code.

\begin{itemize}
    \item This page helped me with float casting when rounding:
    \href{https://stackoverflow.com/questions/5456801/c-int-float-casting}
    {stackoverflow.com}

    \item This stack post helped me round my answers to two decimal places:
    \href{https://stackoverflow.com/questions/1343890/how-do-i-restrict-a-float-value-to-only-two-places-after-the-decimal-point-in-c}{stackoverflow.com}
    
    \item The textbook helped me with basic algorithm and data structure definitions: \href{http://jeffe.cs.illinois.edu/teaching/algorithms/book/Algorithms-JeffE.pdf}{Algorithms textbook}

    \item Your website helped me form and articulate descriptions for each data structure and algorithm used: \href{https://www.labouseur.com/courses/algorithms/}{Labouseur.com}

    \item This Java source code helped me write the hashing and chaining for my program:
    \href{https://www.labouseur.com/courses/algorithms/Hashing.java.html}{Hashing.java}

    \item This video helped me understand hash tables and how they operate:
    \href{https://youtu.be/shs0KM3wKv8?si=T-fq8pJj0R4z_1ZD}{Data Structures: Hash Tables}

    \item A stack overflow post that helped me iterate through a linked list:
    \href{https://stackoverflow.com/questions/17450085/traversing-a-single-linked-list-in-order}{stackoverflow.com}

    \item Quick lookup to find ASCII values from characters in C++:
    \href{https://www.programiz.com/cpp-programming/examples/ASCII-value-character}{ASCII from Char}

    \item Used this line of code to set the size and allocate null pointers to a vector:
\href{https://www.tutorialspoint.com/cpp_standard_library/cpp_vector_resize.htm}{Resize Vector}


    
    
    
\end{itemize}

\pagebreak
%----------------------------------------------------------------------------------------
%   APA REFERENCES
%----------------------------------------------------------------------------------------
% The following two commands are all you need in the initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
%\bibliography{lab1} 
% You must have a proper ".bib" file and remember to run:
% latex bibtex latex latex
% to resolve all references.



\end{document}
